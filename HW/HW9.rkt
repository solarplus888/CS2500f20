;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname HW9) (read-case-sensitive #t) (teachpacks ((lib "image.rkt" "teachpack" "2htdp") (lib "universe.rkt" "teachpack" "2htdp"))) (htdp-settings #(#t constructor repeating-decimal #f #t none #f ((lib "image.rkt" "teachpack" "2htdp") (lib "universe.rkt" "teachpack" "2htdp")) #f)))
#|
Exercise 1
Design a function scalar-matrix, which, for given numbers n and k, produces an n×n matrix (a list of lists of numbers),
where the diagonal entries (first of the first row, second of the second row, etc.) are k and all other entries are 0.
For example, (scalar-matrix 3 2) should produce a representation of the following matrix

2 0 0
0 2 0
0 0 2
|#

;scalar-matrix: n k -> [List-Of-List-Of Numbers]
;As above
(check-expect (scalar-matrix 3 2) (list (list 2 0 0)(list 0 2 0)(list 0 0 2)))

(define (scalar-matrix n k)
  (build-list n
      (lambda (i)
         (build-list n
               (lambda (j)                              
                   (if (= i j)
                       k
                       0))))))

#|
Exercise 2
Design a function diagonal-matrix, which, given a number n and a function f, produces a diagonal matrix, that is, an n×n matrix
where all diagonal entries are generated by f as follows:

(f 0) 0     0     0
0     (f 1) 0     0
0     0     (f 2) 0
0     0     0     (f 3)

Write at least 3 check-expects using lambda.
|#

;diagonal-matrix: n f -> [List-Of-List-Of Numbers]
;As above
(check-expect (diagonal-matrix 4 (λ(n)n)) (list (list 0 0 0 0)(list 0 1 0 0)(list 0 0 2 0)(list 0 0 0 3)))

(define (diagonal-matrix n f)
  (build-list n
      (lambda (i)
         (build-list n
               (lambda (j)                              
                   (if (= i j)
                       (f i)
                       0))))))

;Exercise 3
;Design a function scalar-matrix/v2 using diagonal-matrix.

;scalar-matrix/v2: n k -> [List-Of-List-Of Numbers]
;As above
(check-expect (scalar-matrix/v2 3 (λ(n)2)) (list (list 2 0 0)(list 0 2 0)(list 0 0 2)))

(define (scalar-matrix/v2 n f)
  (diagonal-matrix n f))

#|
Exercise 4
Design a function matrix->string, which converts a given matrix into a string representation, where each row occupies a separate line.
For example (matrix->string (scalar-matrix 4 1)) should return a string containing
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1

You must use list abstractions to solve this problem. Trailing spaces and newlines are fine. You can assume that each entry in the given matrix is a single digit.
|#

;matrix->string: [n k -> [List-Of-List-Of Numbers]] -> String
;As above
(check-expect (matrix->string (scalar-matrix 4 1))
(list
 "1"
 "0"
 "0"
 "0"
 "0"
 "1"
 "0"
 "0"
 "0"
 "0"
 "1"
 "0"
 "0"
 "0"
 "0"
 "1"))

(define (matrix->string lol)  
  (map (λ(lol)(number->string lol)) (foldr append empty lol)))

;Exercise 5
;Complete the data design recipe for the below data definition for a FamilyTree. Note that yob stands for year of birth.

(define-struct person [name yob parent1 parent2])
; A FamilyTree is one of:
; - "unknown"
; - (make-person String Natural FamilyTree FamilyTree)
;Interpretation: Given a person's name, year of birth and biological parents. "Unknown" means parents unknown.

(define UNKNOWN #false)
(define PERSON-LILY (make-person "lily" 1960 UNKNOWN UNKNOWN))
(define PERSON-JAMES (make-person "james" 1950 UNKNOWN UNKNOWN))
(define PERSON-MOLLY (make-person "molly" 1980 UNKNOWN UNKNOWN))
(define PERSON-ARTHUR (make-person "arthur" 1970 UNKNOWN UNKNOWN))
(define PERSON-HARRY (make-person "harry" 1980 PERSON-LILY PERSON-JAMES))
(define PERSON-GINNY (make-person "ginny" 2000 PERSON-MOLLY PERSON-ARTHUR))
(define PERSON-ALBUS (make-person "albus" 1000 PERSON-HARRY PERSON-GINNY))

(define (person-temp p)
  (...
   (cond
     [(boolean? p)...]
     [(person? p)...
      (person-name p)
      (person-yob p)...
      (person-temp(person-parent1 p))...
      (person-temp(person-parent2 p))...])))
     
;Exercise 6
;Design the function max-age which computes the maximum age in a given FamilyTree.
;Assume that everybody was born on January 1st and is still alive. "unknown"’s age is 0.

;max-age: person -> number
;As above
(check-expect (max-age PERSON-ALBUS)(- 2022 1000))
(check-expect (max-age PERSON-HARRY)(- 2022 1950))

(define (max-age p)
  (cond
     [(boolean? p)0]
     [(person? p)
      (max(- 2022 (person-yob p))
      (max-age(person-parent1 p))
      (max-age(person-parent2 p)))]))

;Exercise 7
;Design the function valid-ft? which validates the given family tree. That is, it should return #true if the given FamilyTree is valid and #false otherwise.
;A FamilyTree is valid if and only if every person in the tree is younger than their parents.

;valid-ft?: person -> Boolean
;As above
(check-expect (valid-ft? PERSON-ALBUS)#false)
(check-expect (valid-ft? PERSON-HARRY)#true)

(define (valid-ft? p)
  (cond
     [(boolean? p)#true]
     [(person? p)
      (and(> (person-yob p)(if (boolean? (person-parent1 p))
                               0
                               (person-yob (person-parent1 p))))
          (> (person-yob p)(if (boolean? (person-parent2 p))
                               0
                               (person-yob (person-parent2 p))))
          (valid-ft?(person-parent1 p))
          (valid-ft?(person-parent2 p)))]))

;Exercise 8
;Design a function, count-bricks, that takes a lego building and produces the total number of lego bricks in that building.

(define-struct lego (label color width))
; A Lego is a (make-lego String String Number)
; Interpretation: (make-lego l c w) is a lego brick
; with a label _l_, color _c_, and width _w_ (in pixels).
#|
(make-lego "1" "yellow" 40)
(make-lego "2" "blue" 60)
(make-lego "3" "red" 40)
(make-lego "4" "purple" 80)
(make-lego "5" "green" 40)
(make-lego "6" "orange" 60)
(make-lego "7" "red" 40)
|#
(define (lego-temp x)
  (...(lego-label x)...
      (lego-color x)...
      (lego-width x)...))
 
(define-struct bigger (lego left right))
; A LegoBldg (lego building) is one of:
; - Lego
; - (make-bigger Lego LegoBldg LegoBldg)
; Interpretation: (make-bigger l lft rgt) makes a bigger
; lego building by putting a lego brick _l_ on top of two lego
; buildings _lft_ (left) and _rgt_ (right).
(define LEGO1 (make-bigger (make-lego "4" "purple" 80)
                          (make-bigger (make-lego "2" "blue" 60)
                                       (make-lego "1" "yellow" 40)
                                       (make-lego "3" "red" 40))
                          (make-bigger (make-lego "6" "orange" 60)
                                       (make-lego "5" "green" 40)
                                       (make-lego "7" "red" 40))))

(define LEGO2 (make-bigger (make-lego "4" "purple" 80)
                          (make-bigger (make-lego "2" "blue" 60)
                                       (make-lego "1" "yellow" 40)
                                       (make-lego "3" "red" 40))
                          (make-lego "6" "orange" 60)))

(define (bigger-temp x)
  (...
   (cond
     [(lego? x) (lego-temp x)]
     [(bigger? x)...
      (lego-temp(bigger-lego x))...
      (bigger-temp(bigger-left x))...
      (bigger-temp(bigger-right x))...
      ])))

;count-bricks: LegoBldg -> Number
;As above
(check-expect (count-bricks LEGO1)7)
(check-expect (count-bricks LEGO2)5)

(define (count-bricks x)
  (cond
     [(lego? x) 1]
     [(bigger? x)
      (+ 1
      (count-bricks(bigger-left x))
      (count-bricks(bigger-right x)))
      ]))

;Exercise 9 [INCOMPLETE: Not familiar on processing tree structure]
;Each lego brick is 10 pixels tall. Design a function, how-high, that takes a lego building and produces the total height of the lego building (in pixels).

;how-high: LegoBldg -> Number
;As above
#|
(check-expect (how-high LEGO1)(* 10 3))
(check-expect (how-high LEGO2)(* 10 3))

(define (how-high x)
   (cond
     [(lego? x) 0]
     [(bigger? x)
      (+ 1
      (max(how-high(bigger-left x))
          (how-high(bigger-right x))))
      ]))
|#

;Exercise 10
;Design a function, contains-colored-brick?, that takes a lego building and a color, and determines whether the building contains a lego brick of the given color.

;contains-colored-brick?: LegoBldg String -> Boolean
;As above

(check-expect (contains-colored-brick? LEGO1 "green")#true)
(check-expect (contains-colored-brick? LEGO2 "green")#false)

(define (contains-colored-brick? x s)
  (cond
     [(lego? x) (if (string=? (lego-color x) s)
                    #true
                    #false)]
     [(bigger? x)
      (or (if (string=? (lego-color(bigger-lego x)) s)
          #true
          #false)
          (contains-colored-brick?(bigger-left x) s)
          (contains-colored-brick?(bigger-right x) s))]))

;Exercise 11 [INCOMPLETE: don't know how to traverse a tree structure]
;Design a function, find-colored-brick, that takes a lego building and a color and finds any lego with the given color in the building,
;or returns #false if there are no such legos.

; A MaybeLego is one of:
; - #false
; - Lego

;find-colored-brick: LegoBldg String -> MaybeLego
;As above
#|
(check-expect (find-colored-brick LEGO1 "red")(make-lego "3" "red" 40))
;(check-expect (find-colored-brick LEGO2 "purple")#false)

(define (find-colored-brick x s)
  (cond
     [(lego? x) (if (string=? (lego-color x) s)
                    (make-lego (lego-label x)(lego-color x)(lego-width x))
                    #false)]    
     [(bigger? x)(if (string=? (lego-color(bigger-lego x)) s)       
                     (make-lego (lego-label (bigger-lego x))(lego-color (bigger-lego x))(lego-width (bigger-lego x)))
                     (find-colored-brick(bigger-left x) s))]))
|#

;Exercise 12 Design a function, lb->image, that takes a lego building and produces an image of the building. [INCOMPLETE]





